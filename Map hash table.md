### Map hash table

Java 中使用Map 接口描述映射结构，描述的是键key-值value 对应关系。 map没有key重复，且每个键只对应特定值

##### List-Based Map

stores entries of the map in a doubly-linked-list in arbitrary order

put takes O(n)

get and remove take O(n)

### hash table

继承Dictionary 类，实现Map接口。

读，增，删，改 ： O（1）

提供快速插入和寻找， hard to order

limited size, based on array

##### hash function

一个把查找表中的关键字映射称该关键字对应的地址的函数，

Hash(key) = Addr

- helps calculate the best index an item should go in.

- to store values in an array with a limited size
- it does it in a way that the array doesn’t need to be searched through to find it
  - enter values in any order
  - be able to <u>find them using a calculation</u> instead of searching through the array

- 散列函数的定义域需包含全部需要存储的关键字

- 值域的范围依赖于散列表的大小或地址范围
- 散列函数计算出的地址应能等概率，均匀的分布在整个地址空间（减少冲突产生）

构造方法：

- 取关键字的线性函数值为散列地址
  - H（key） = a * key + b
  - 简单 没有冲突
- 除留余数法
  - 取一个不大于m但最接近或等于m的质数p，利用公式
  - H（key） = key % p
  - 把关键之转换成散列地址
  - 关键是： 选好p 使得每一个关键字通过该函数转换后等概率映射到散列空间上的任一地址，尽可能减少冲突的可能性

#### Hash Function:

hash code is applied first, and compression function is applied next on the result

h(x) = h2(h1(x))



The goal of the hash function is to “disperse” the keys in an apparently random way.让key明显的随机分布

##### hash code

returns an integer value, generated by a hshing algorithm

mapping keys to integers

h1: keys —> integers 

###### 	Memory address

​		

##### compressionn function

h2: integers —> [0, N-1]









 映射到同一哈希地址上的关键字称为同义词。

#### 哈希碰撞

多个key 通过 哈希函数 同时映射到相同的内存地址上

在此地址，有多个value。这时我们用linked list储存这些值



##### 拉链法 Separate Chaining

假设哈希函数得到哈希地址域在区间【0， m-1】 上，建立m个空链表，由哈希函数对key转换后，映射到同一哈希地址 i 的同义词均加入同一个链表。

散列表中只存储所有同义词子表的头指针。





##### 开放定址法 open addressing

所谓的[开放定址法](http://www.nowamagic.net/academy/tag/开放定址法)就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。



###### 线性探测法Linear Probing



有冲突，找到下一个空位置，没有冲突，存入。

会出现堆积问题：大量元素在相邻的散列地址上，降低查找效率。



 Hi = (Hash(key) + di ) mod m (1 ≤ i < m)

 其中，Hash(key)是哈希函数，m是哈希表的长度，di 增量序列 1，2，···，m - 1, 且di = i 。

###### 双向探测法 Quadratic Probing

社发生冲突的地址为d，平方探测法得到的新的地址序列为d+1^2, d-1^2, d+2^2, …

避免了出现堆积问题，但不能探测到表上所有单元。

 Hi = (Hash(key) ± di) mod m



##### 双散列 double hashing

使用两个散列函数，当第一个散列函数h(key) 得到的地址发生冲突， 利用第二个散列函数计算该key的地址增量。



d(k) is chosen in a way that would minimize clustering as much as possible

d(k) = q - k mod q, where q < N, q is a prime

