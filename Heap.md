### Heap

我们常用的堆是二叉堆（binary heap）也就是基于二叉树结构实现的堆。

堆不一定是二叉树。

堆是一种特殊的二叉树，它必须是完全二叉树（complete tree），也就是说如果你将一颗二叉树按照从上到下从左到右的顺序依次从1开始编号，编号序列是连续自然数而中间没有空缺。



对于任何一个数字集合，我们如何知道并且尽可能快速地知道他的最（小）值。

排序问题、前K个元素、第K个元素等等此类的问题 

##### 构建堆

堆的构建可理解为节点的插入或节点的下沉

插入：新的节点插入老节点的子节点进行上浮操作

下沉：新节点每次从堆顶“插入” ，进而每次都需要从堆顶进行下沉操作

##### （下沉）删除堆顶元素 Heapify

当节点元素比子节点大（最小堆）

或节点元素比子节点小（最大堆）时，

将其值互换。



##### （上浮）插入一个节点

O(logn)

先将新节点插入最底层的最右边，然后逐层与它的父节点比较，如果它的值比父节点的值小（最小堆为例），交换两个节点，也叫“节点上浮”

所以我们可以观察到，最坏的情况是我们插入了一个最小的点，然后将它一路“上浮”到跟节点，走过的路径就是二叉树的高度，如果我们用N代表节点总数，它的时间复杂度就是O(logN)。

例：

向已经符合堆结构的[12, 10,9, 5, 6, 8]中插入13，

1. 将13 插入9右子节点处
2. 与9互换值
3. 此时13位于9的位置，13与12互换值

##### 删除

O(logn)

找到最后一个元素，将要删除的节点值与最后一个元素节点值互换 并删掉最后一个节点。再对互换后的节点进行下沉

例：

在已经符合堆结构的[12, 10,9, 5, 6, 8]中删除12



先将12与8互换，再删除掉最后一个节点

对8进行下沉操作，与9，10做比较，最大堆的第二条性质，节点要比子节点大，因此与较大的子节点10互换，继续下沉。

重复2的操作直至无法下沉 

##### 实现：

heap用 priority queue 实现



left-son-id = father-id * 2

right son id = father id * 2 + 1

数组模拟二叉树

最大堆max-heap； 

每个节点的key都大于等于子节点key

max-heap最大元素在根节点，位于array头



最小堆min-heap 

每个节点key都小于子节点key

min-heap最小元素在根节点 位于array头